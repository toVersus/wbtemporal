// Package jupyterhub provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package jupyterhub

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	Oauth2Scopes = "oauth2.Scopes"
	TokenScopes  = "token.Scopes"
)

// Defines values for ServerPending.
const (
	ServerPendingSpawn ServerPending = "spawn"
	ServerPendingStop  ServerPending = "stop"
)

// Defines values for UserPending.
const (
	UserPendingSpawn UserPending = "spawn"
	UserPendingStop  UserPending = "stop"
)

// Defines values for GetUsersParamsState.
const (
	Active   GetUsersParamsState = "active"
	Inactive GetUsersParamsState = "inactive"
	Ready    GetUsersParamsState = "ready"
)

// Group defines model for Group.
type Group struct {
	// Name The group's name
	Name *string `json:"name,omitempty"`

	// Properties Group properties (a dictionary).
	//
	// Unused by JupyterHub itself,
	// but an extension point to store information about groups.
	//
	// Added in JupyterHub 3.2.
	Properties *map[string]interface{} `json:"properties,omitempty"`

	// Roles The names of roles this group has
	Roles *[]string `json:"roles,omitempty"`

	// Users The names of users who are members of this group
	Users *[]string `json:"users,omitempty"`
}

// RequestIdentity defines model for RequestIdentity.
type RequestIdentity struct {
	// Scopes The list of all expanded scopes the request credentials have access to.
	//
	// Added in 2.0.
	Scopes *[]string `json:"scopes,omitempty"`

	// SessionId The session id associated with the request's OAuth token, if any.
	// null, if the request token not associated with a session id.
	//
	// Added in 2.0.
	SessionId *string `json:"session_id"`
	union     json.RawMessage
}

// Server defines model for Server.
type Server struct {
	// LastActivity UTC timestamp last-seen activity on this server.
	LastActivity *time.Time `json:"last_activity,omitempty"`

	// Name The server's name. The user's default server has an empty name ('')
	Name *string `json:"name,omitempty"`

	// Pending The currently pending action, if any.
	// A server is not ready if an action is pending.
	Pending *ServerPending `json:"pending,omitempty"`

	// ProgressUrl The URL for an event-stream to retrieve events during a spawn.
	ProgressUrl *string `json:"progress_url,omitempty"`

	// Ready Whether the server is ready for traffic.
	// Will always be false when any transition is pending.
	Ready *bool `json:"ready,omitempty"`

	// Started UTC timestamp when the server was last started.
	Started *time.Time `json:"started,omitempty"`

	// State Arbitrary internal state from this server's spawner. Only available on the hub's users list or get-user-by-name method, and only with admin:users:server_state scope. None otherwise.
	State *map[string]interface{} `json:"state,omitempty"`

	// Stopped Whether the server is stopped. Added in JupyterHub 3.0,
	// and only useful when using the `?include_stopped_servers`
	// request parameter.
	// Now that stopped servers may be included (since JupyterHub 3.0),
	// this is the simplest way to select stopped servers.
	// Always equivalent to `not (ready or pending)`.
	Stopped *bool `json:"stopped,omitempty"`

	// Url The URL where the server can be accessed
	// (typically /user/:name/:server.name/).
	Url *string `json:"url,omitempty"`

	// UserOptions User specified options for the user's spawned instance of a single-user server.
	UserOptions *map[string]interface{} `json:"user_options,omitempty"`
}

// ServerPending The currently pending action, if any.
// A server is not ready if an action is pending.
type ServerPending string

// Service defines model for Service.
type Service struct {
	// Admin Whether the service is an admin
	Admin *bool `json:"admin,omitempty"`

	// Command The command used to start the service (if managed)
	Command *[]string `json:"command,omitempty"`

	// Info Additional information a deployment can attach to a service.
	// JupyterHub does not use this field.
	Info *map[string]interface{} `json:"info,omitempty"`

	// Name The service's name
	Name *string `json:"name,omitempty"`

	// Pid The PID of the service process (if managed)
	Pid *float32 `json:"pid,omitempty"`

	// Prefix The proxied URL prefix to the service's url
	Prefix *string `json:"prefix,omitempty"`

	// Roles The names of roles this service has
	Roles *[]string `json:"roles,omitempty"`

	// Url The internal url where the service is running
	Url *string `json:"url,omitempty"`
}

// Token defines model for Token.
type Token struct {
	// Created Timestamp when this token was created
	Created *time.Time `json:"created,omitempty"`

	// ExpiresAt Timestamp when this token expires. Null if there is no expiry.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Id The id of the API token. Used for modifying or deleting the token.
	Id *string `json:"id,omitempty"`

	// LastActivity Timestamp of last-seen activity using this token.
	// Can be null if token has never been used.
	LastActivity *time.Time `json:"last_activity,omitempty"`

	// Note A note about the token, typically describing what it was created for.
	Note *string `json:"note,omitempty"`

	// Roles Deprecated in JupyterHub 3, always an empty list. Tokens have 'scopes' starting from JupyterHub 3.
	Roles *[]string `json:"roles,omitempty"`

	// Scopes List of scopes this token has been assigned. New in JupyterHub 3. In JupyterHub 2.x, tokens were assigned 'roles' insead of scopes.
	Scopes *[]string `json:"scopes,omitempty"`

	// Service The service that owns the token (undefined of owned by a user)
	Service *string `json:"service,omitempty"`

	// SessionId The session id associated with the token, if any.
	// Only used for tokens set during oauth flows.
	//
	// Added in 2.0.
	SessionId *string `json:"session_id"`

	// Token The token itself. Only present in responses to requests for a new token.
	Token *string `json:"token,omitempty"`

	// User The user that owns a token (undefined if owned by a service)
	User *string `json:"user,omitempty"`
}

// User defines model for User.
type User struct {
	// Admin Whether the user is an admin
	Admin *bool `json:"admin,omitempty"`

	// AuthState Authentication state of the user. Only available with admin:users:auth_state
	// scope. None otherwise.
	AuthState *map[string]interface{} `json:"auth_state,omitempty"`

	// Groups The names of groups where this user is a member
	Groups *[]string `json:"groups,omitempty"`

	// LastActivity Timestamp of last-seen activity from the user
	LastActivity *time.Time `json:"last_activity,omitempty"`

	// Name The user's name
	Name *string `json:"name,omitempty"`

	// Pending The currently pending action, if any
	Pending *UserPending `json:"pending,omitempty"`

	// Roles The names of roles this user has
	Roles *[]string `json:"roles,omitempty"`

	// Server The user's notebook server's base URL, if running; null if not.
	Server *string `json:"server,omitempty"`

	// Servers The servers for this user.
	// By default: only includes _active_ servers.
	// Changed in 3.0: if `?include_stopped_servers` parameter is specified,
	// stopped servers will be included as well.
	Servers *map[string]Server `json:"servers,omitempty"`
}

// UserPending The currently pending action, if any
type UserPending string

// PostAuthorizationsTokenJSONBody defines parameters for PostAuthorizationsToken.
type PostAuthorizationsTokenJSONBody struct {
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	// Offset Return a number of groups starting at the specified offset.
	// Can be used with limit to paginate.
	// If unspecified, return all groups.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Return a finite number of groups.
	// Can be used with offset to paginate.
	// If unspecified, use api_page_default_limit.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// PutGroupsNamePropertiesJSONBody defines parameters for PutGroupsNameProperties.
type PutGroupsNamePropertiesJSONBody = map[string]interface{}

// PostGroupsNameUsersJSONBody defines parameters for PostGroupsNameUsers.
type PostGroupsNameUsersJSONBody struct {
	// Users List of usernames to add to the group
	Users *[]string `json:"users,omitempty"`
}

// GetOauth2AuthorizeParams defines parameters for GetOauth2Authorize.
type GetOauth2AuthorizeParams struct {
	// ClientId The client id
	ClientId string `form:"client_id" json:"client_id"`

	// ResponseType The response type (always 'code')
	ResponseType string `form:"response_type" json:"response_type"`

	// State A state string
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// RedirectUri The redirect url
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`
}

// PostOauth2TokenFormdataBody defines parameters for PostOauth2Token.
type PostOauth2TokenFormdataBody struct {
	// ClientId The client id
	ClientId string `form:"client_id" json:"client_id"`

	// ClientSecret The client secret
	ClientSecret string `form:"client_secret" json:"client_secret"`

	// Code The code provided by the authorization redirect
	Code string `form:"code" json:"code"`

	// GrantType The grant type (always 'authorization_code')
	GrantType string `form:"grant_type" json:"grant_type"`

	// RedirectUri The redirect url
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`
}

// GetProxyParams defines parameters for GetProxy.
type GetProxyParams struct {
	// Offset Return a number of routes starting at the given offset.
	// Can be used with limit to paginate.
	// If unspecified, return all routes.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Return a finite number of routes.
	// Can be used with offset to paginate.
	// If unspecified, use api_page_default_limit
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// PatchProxyJSONBody defines parameters for PatchProxy.
type PatchProxyJSONBody struct {
	// AuthToken CONFIGPROXY_AUTH_TOKEN for the new proxy
	AuthToken *string `json:"auth_token,omitempty"`

	// Ip IP address of the new proxy
	Ip *string `json:"ip,omitempty"`

	// Port Port of the new proxy
	Port *string `json:"port,omitempty"`

	// Protocol Protocol of new proxy, if changed
	Protocol *string `json:"protocol,omitempty"`
}

// PostShutdownJSONBody defines parameters for PostShutdown.
type PostShutdownJSONBody struct {
	// Proxy Whether the proxy should be shutdown as well (default from Hub config)
	Proxy *bool `json:"proxy,omitempty"`

	// Servers Whether users' notebook servers should be shutdown as well (default from Hub config)
	Servers *bool `json:"servers,omitempty"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// State Return only users who have servers in the given state.
	// If unspecified, return all users.
	//
	// active: all users with any active servers (ready OR pending)
	// ready: all users who have any ready servers (running, not pending)
	// inactive: all users who have *no* active servers (complement of active)
	//
	// Added in JupyterHub 1.3
	State *GetUsersParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Offset Return a number users starting at the given offset.
	// Can be used with limit to paginate.
	// If unspecified, return all users.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Return a finite number of users.
	// Can be used with offset to paginate.
	// If unspecified, use api_page_default_limit.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// IncludeStoppedServers Include stopped servers in user model(s).
	// Added in JupyterHub 3.0.
	// Allows retrieval of information about stopped servers,
	// such as activity and state fields.
	IncludeStoppedServers *bool `form:"include_stopped_servers,omitempty" json:"include_stopped_servers,omitempty"`
}

// GetUsersParamsState defines parameters for GetUsers.
type GetUsersParamsState string

// PostUsersJSONBody defines parameters for PostUsers.
type PostUsersJSONBody struct {
	// Admin whether the created users should be admins
	Admin *bool `json:"admin,omitempty"`

	// Usernames list of usernames to create on the Hub
	Usernames *[]string `json:"usernames,omitempty"`
}

// PatchUsersNameJSONBody defines parameters for PatchUsersName.
type PatchUsersNameJSONBody struct {
	// Admin update admin (optional, if another key is updated i.e. name)
	Admin *bool `json:"admin,omitempty"`

	// Name the new name (optional, if another key is updated i.e. admin)
	Name *string `json:"name,omitempty"`
}

// PostUsersNameActivityJSONBody defines parameters for PostUsersNameActivity.
type PostUsersNameActivityJSONBody struct {
	// LastActivity Timestamp of last-seen activity for this user.
	// Only needed if this is not activity associated
	// with using a given server.
	LastActivity *time.Time `json:"last_activity,omitempty"`

	// Servers Register activity for specific servers by name.
	// The keys of this dict are the names of servers.
	// The default server has an empty name ('').
	Servers *struct {
		// serverName Activity for a single server.
		serverName *struct {
			// LastActivity Timestamp of last-seen activity on this server.
			LastActivity time.Time `json:"last_activity"`
		} `json:"<server name>,omitempty"`
	} `json:"servers,omitempty"`
}

// PostUsersNameServerJSONBody defines parameters for PostUsersNameServer.
type PostUsersNameServerJSONBody = map[string]interface{}

// PostUsersNameServersServerNameJSONBody defines parameters for PostUsersNameServersServerName.
type PostUsersNameServersServerNameJSONBody = map[string]interface{}

// PostUsersNameTokensJSONBody defines parameters for PostUsersNameTokens.
type PostUsersNameTokensJSONBody struct {
	// ExpiresIn lifetime (in seconds) after which the requested token will expire.
	ExpiresIn *float32 `json:"expires_in,omitempty"`

	// Note A note attached to the token for future bookkeeping
	Note *string `json:"note,omitempty"`

	// Roles A list of role names from which to derive scopes.
	// This is a shortcut for assigning collections of scopes;
	// Tokens do not retain role assignment.
	// (Changed in 3.0: roles are immediately resolved to scopes
	// instead of stored on roles.)
	Roles *[]string `json:"roles,omitempty"`

	// Scopes A list of scopes that the token should have.
	// (new in JupyterHub 3.0).
	Scopes *[]string `json:"scopes,omitempty"`
}

// PostAuthorizationsTokenJSONRequestBody defines body for PostAuthorizationsToken for application/json ContentType.
type PostAuthorizationsTokenJSONRequestBody PostAuthorizationsTokenJSONBody

// PutGroupsNamePropertiesJSONRequestBody defines body for PutGroupsNameProperties for application/json ContentType.
type PutGroupsNamePropertiesJSONRequestBody = PutGroupsNamePropertiesJSONBody

// PostGroupsNameUsersJSONRequestBody defines body for PostGroupsNameUsers for application/json ContentType.
type PostGroupsNameUsersJSONRequestBody PostGroupsNameUsersJSONBody

// PostOauth2TokenFormdataRequestBody defines body for PostOauth2Token for application/x-www-form-urlencoded ContentType.
type PostOauth2TokenFormdataRequestBody PostOauth2TokenFormdataBody

// PatchProxyJSONRequestBody defines body for PatchProxy for application/json ContentType.
type PatchProxyJSONRequestBody PatchProxyJSONBody

// PostShutdownJSONRequestBody defines body for PostShutdown for application/json ContentType.
type PostShutdownJSONRequestBody PostShutdownJSONBody

// PostUsersJSONRequestBody defines body for PostUsers for application/json ContentType.
type PostUsersJSONRequestBody PostUsersJSONBody

// PatchUsersNameJSONRequestBody defines body for PatchUsersName for application/json ContentType.
type PatchUsersNameJSONRequestBody PatchUsersNameJSONBody

// PostUsersNameActivityJSONRequestBody defines body for PostUsersNameActivity for application/json ContentType.
type PostUsersNameActivityJSONRequestBody PostUsersNameActivityJSONBody

// PostUsersNameServerJSONRequestBody defines body for PostUsersNameServer for application/json ContentType.
type PostUsersNameServerJSONRequestBody = PostUsersNameServerJSONBody

// PostUsersNameServersServerNameJSONRequestBody defines body for PostUsersNameServersServerName for application/json ContentType.
type PostUsersNameServersServerNameJSONRequestBody = PostUsersNameServersServerNameJSONBody

// PostUsersNameTokensJSONRequestBody defines body for PostUsersNameTokens for application/json ContentType.
type PostUsersNameTokensJSONRequestBody PostUsersNameTokensJSONBody

// AsUser returns the union data inside the RequestIdentity as a User
func (t RequestIdentity) AsUser() (User, error) {
	var body User
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUser overwrites any union data inside the RequestIdentity as the provided User
func (t *RequestIdentity) FromUser(v User) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUser performs a merge with any union data inside the RequestIdentity, using the provided User
func (t *RequestIdentity) MergeUser(v User) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsService returns the union data inside the RequestIdentity as a Service
func (t RequestIdentity) AsService() (Service, error) {
	var body Service
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromService overwrites any union data inside the RequestIdentity as the provided Service
func (t *RequestIdentity) FromService(v Service) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeService performs a merge with any union data inside the RequestIdentity, using the provided Service
func (t *RequestIdentity) MergeService(v Service) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestIdentity) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Scopes != nil {
		object["scopes"], err = json.Marshal(t.Scopes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scopes': %w", err)
		}
	}

	if t.SessionId != nil {
		object["session_id"], err = json.Marshal(t.SessionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'session_id': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *RequestIdentity) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["scopes"]; found {
		err = json.Unmarshal(raw, &t.Scopes)
		if err != nil {
			return fmt.Errorf("error reading 'scopes': %w", err)
		}
	}

	if raw, found := object["session_id"]; found {
		err = json.Unmarshal(raw, &t.SessionId)
		if err != nil {
			return fmt.Errorf("error reading 'session_id': %w", err)
		}
	}

	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Get request
	Get(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorizationsCookieCookieNameCookieValue request
	GetAuthorizationsCookieCookieNameCookieValue(ctx context.Context, cookieName string, cookieValue string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorizationsToken request with any body
	PostAuthorizationsTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorizationsToken(ctx context.Context, body PostAuthorizationsTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorizationsTokenToken request
	GetAuthorizationsTokenToken(ctx context.Context, token string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroups request
	GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupsName request
	DeleteGroupsName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsName request
	GetGroupsName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGroupsName request
	PostGroupsName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutGroupsNameProperties request with any body
	PutGroupsNamePropertiesWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutGroupsNameProperties(ctx context.Context, name string, body PutGroupsNamePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupsNameUsers request
	DeleteGroupsNameUsers(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGroupsNameUsers request with any body
	PostGroupsNameUsersWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGroupsNameUsers(ctx context.Context, name string, body PostGroupsNameUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInfo request
	GetInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOauth2Authorize request
	GetOauth2Authorize(ctx context.Context, params *GetOauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOauth2Token request with any body
	PostOauth2TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOauth2TokenWithFormdataBody(ctx context.Context, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProxy request
	GetProxy(ctx context.Context, params *GetProxyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchProxy request with any body
	PatchProxyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchProxy(ctx context.Context, body PatchProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProxy request
	PostProxy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServices request
	GetServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesName request
	GetServicesName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostShutdown request with any body
	PostShutdownWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostShutdown(ctx context.Context, body PostShutdownJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsers request with any body
	PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUsers(ctx context.Context, body PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUsersName request
	DeleteUsersName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersName request
	GetUsersName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUsersName request with any body
	PatchUsersNameWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUsersName(ctx context.Context, name string, body PatchUsersNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsersName request
	PostUsersName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsersNameActivity request with any body
	PostUsersNameActivityWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUsersNameActivity(ctx context.Context, name string, body PostUsersNameActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUsersNameServer request
	DeleteUsersNameServer(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsersNameServer request with any body
	PostUsersNameServerWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUsersNameServer(ctx context.Context, name string, body PostUsersNameServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUsersNameServersServerName request
	DeleteUsersNameServersServerName(ctx context.Context, name string, serverName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsersNameServersServerName request with any body
	PostUsersNameServersServerNameWithBody(ctx context.Context, name string, serverName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUsersNameServersServerName(ctx context.Context, name string, serverName string, body PostUsersNameServersServerNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersNameTokens request
	GetUsersNameTokens(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsersNameTokens request with any body
	PostUsersNameTokensWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUsersNameTokens(ctx context.Context, name string, body PostUsersNameTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUsersNameTokensTokenId request
	DeleteUsersNameTokensTokenId(ctx context.Context, name string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersNameTokensTokenId request
	GetUsersNameTokensTokenId(ctx context.Context, name string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Get(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorizationsCookieCookieNameCookieValue(ctx context.Context, cookieName string, cookieValue string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorizationsCookieCookieNameCookieValueRequest(c.Server, cookieName, cookieValue)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorizationsTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorizationsTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorizationsToken(ctx context.Context, body PostAuthorizationsTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorizationsTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorizationsTokenToken(ctx context.Context, token string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorizationsTokenTokenRequest(c.Server, token)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupsName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupsNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupsName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGroupsName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGroupsNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutGroupsNamePropertiesWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutGroupsNamePropertiesRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutGroupsNameProperties(ctx context.Context, name string, body PutGroupsNamePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutGroupsNamePropertiesRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupsNameUsers(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupsNameUsersRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGroupsNameUsersWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGroupsNameUsersRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGroupsNameUsers(ctx context.Context, name string, body PostGroupsNameUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGroupsNameUsersRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOauth2Authorize(ctx context.Context, params *GetOauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOauth2AuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOauth2TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOauth2TokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOauth2TokenWithFormdataBody(ctx context.Context, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOauth2TokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProxy(ctx context.Context, params *GetProxyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProxyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchProxyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchProxyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchProxy(ctx context.Context, body PatchProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchProxyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProxy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProxyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShutdownWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShutdownRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShutdown(ctx context.Context, body PostShutdownJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShutdownRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsers(ctx context.Context, body PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUsersName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUsersNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUsersNameWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUsersNameRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUsersName(ctx context.Context, name string, body PatchUsersNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUsersNameRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersNameActivityWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersNameActivityRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersNameActivity(ctx context.Context, name string, body PostUsersNameActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersNameActivityRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUsersNameServer(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUsersNameServerRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersNameServerWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersNameServerRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersNameServer(ctx context.Context, name string, body PostUsersNameServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersNameServerRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUsersNameServersServerName(ctx context.Context, name string, serverName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUsersNameServersServerNameRequest(c.Server, name, serverName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersNameServersServerNameWithBody(ctx context.Context, name string, serverName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersNameServersServerNameRequestWithBody(c.Server, name, serverName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersNameServersServerName(ctx context.Context, name string, serverName string, body PostUsersNameServersServerNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersNameServersServerNameRequest(c.Server, name, serverName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersNameTokens(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersNameTokensRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersNameTokensWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersNameTokensRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersNameTokens(ctx context.Context, name string, body PostUsersNameTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersNameTokensRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUsersNameTokensTokenId(ctx context.Context, name string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUsersNameTokensTokenIdRequest(c.Server, name, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersNameTokensTokenId(ctx context.Context, name string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersNameTokensTokenIdRequest(c.Server, name, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetRequest generates requests for Get
func NewGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthorizationsCookieCookieNameCookieValueRequest generates requests for GetAuthorizationsCookieCookieNameCookieValue
func NewGetAuthorizationsCookieCookieNameCookieValueRequest(server string, cookieName string, cookieValue string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cookie_name", runtime.ParamLocationPath, cookieName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cookie_value", runtime.ParamLocationPath, cookieValue)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/cookie/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAuthorizationsTokenRequest calls the generic PostAuthorizationsToken builder with application/json body
func NewPostAuthorizationsTokenRequest(server string, body PostAuthorizationsTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthorizationsTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAuthorizationsTokenRequestWithBody generates requests for PostAuthorizationsToken with any type of body
func NewPostAuthorizationsTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAuthorizationsTokenTokenRequest generates requests for GetAuthorizationsTokenToken
func NewGetAuthorizationsTokenTokenRequest(server string, token string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/token/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsRequest generates requests for GetGroups
func NewGetGroupsRequest(server string, params *GetGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteGroupsNameRequest generates requests for DeleteGroupsName
func NewDeleteGroupsNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsNameRequest generates requests for GetGroupsName
func NewGetGroupsNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostGroupsNameRequest generates requests for PostGroupsName
func NewPostGroupsNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutGroupsNamePropertiesRequest calls the generic PutGroupsNameProperties builder with application/json body
func NewPutGroupsNamePropertiesRequest(server string, name string, body PutGroupsNamePropertiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutGroupsNamePropertiesRequestWithBody(server, name, "application/json", bodyReader)
}

// NewPutGroupsNamePropertiesRequestWithBody generates requests for PutGroupsNameProperties with any type of body
func NewPutGroupsNamePropertiesRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupsNameUsersRequest generates requests for DeleteGroupsNameUsers
func NewDeleteGroupsNameUsersRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostGroupsNameUsersRequest calls the generic PostGroupsNameUsers builder with application/json body
func NewPostGroupsNameUsersRequest(server string, name string, body PostGroupsNameUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGroupsNameUsersRequestWithBody(server, name, "application/json", bodyReader)
}

// NewPostGroupsNameUsersRequestWithBody generates requests for PostGroupsNameUsers with any type of body
func NewPostGroupsNameUsersRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInfoRequest generates requests for GetInfo
func NewGetInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOauth2AuthorizeRequest generates requests for GetOauth2Authorize
func NewGetOauth2AuthorizeRequest(server string, params *GetOauth2AuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth2/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOauth2TokenRequestWithFormdataBody calls the generic PostOauth2Token builder with application/x-www-form-urlencoded body
func NewPostOauth2TokenRequestWithFormdataBody(server string, body PostOauth2TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostOauth2TokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostOauth2TokenRequestWithBody generates requests for PostOauth2Token with any type of body
func NewPostOauth2TokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth2/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProxyRequest generates requests for GetProxy
func NewGetProxyRequest(server string, params *GetProxyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proxy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchProxyRequest calls the generic PatchProxy builder with application/json body
func NewPatchProxyRequest(server string, body PatchProxyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchProxyRequestWithBody(server, "application/json", bodyReader)
}

// NewPatchProxyRequestWithBody generates requests for PatchProxy with any type of body
func NewPatchProxyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proxy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProxyRequest generates requests for PostProxy
func NewPostProxyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proxy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesRequest generates requests for GetServices
func NewGetServicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesNameRequest generates requests for GetServicesName
func NewGetServicesNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostShutdownRequest calls the generic PostShutdown builder with application/json body
func NewPostShutdownRequest(server string, body PostShutdownJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostShutdownRequestWithBody(server, "application/json", bodyReader)
}

// NewPostShutdownRequestWithBody generates requests for PostShutdown with any type of body
func NewPostShutdownRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shutdown")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeStoppedServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_stopped_servers", runtime.ParamLocationQuery, *params.IncludeStoppedServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUsersRequest calls the generic PostUsers builder with application/json body
func NewPostUsersRequest(server string, body PostUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUsersRequestWithBody generates requests for PostUsers with any type of body
func NewPostUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUsersNameRequest generates requests for DeleteUsersName
func NewDeleteUsersNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersNameRequest generates requests for GetUsersName
func NewGetUsersNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUsersNameRequest calls the generic PatchUsersName builder with application/json body
func NewPatchUsersNameRequest(server string, name string, body PatchUsersNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUsersNameRequestWithBody(server, name, "application/json", bodyReader)
}

// NewPatchUsersNameRequestWithBody generates requests for PatchUsersName with any type of body
func NewPatchUsersNameRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUsersNameRequest generates requests for PostUsersName
func NewPostUsersNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUsersNameActivityRequest calls the generic PostUsersNameActivity builder with application/json body
func NewPostUsersNameActivityRequest(server string, name string, body PostUsersNameActivityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersNameActivityRequestWithBody(server, name, "application/json", bodyReader)
}

// NewPostUsersNameActivityRequestWithBody generates requests for PostUsersNameActivity with any type of body
func NewPostUsersNameActivityRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/activity", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUsersNameServerRequest generates requests for DeleteUsersNameServer
func NewDeleteUsersNameServerRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/server", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUsersNameServerRequest calls the generic PostUsersNameServer builder with application/json body
func NewPostUsersNameServerRequest(server string, name string, body PostUsersNameServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersNameServerRequestWithBody(server, name, "application/json", bodyReader)
}

// NewPostUsersNameServerRequestWithBody generates requests for PostUsersNameServer with any type of body
func NewPostUsersNameServerRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/server", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUsersNameServersServerNameRequest generates requests for DeleteUsersNameServersServerName
func NewDeleteUsersNameServersServerNameRequest(server string, name string, serverName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "server_name", runtime.ParamLocationPath, serverName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUsersNameServersServerNameRequest calls the generic PostUsersNameServersServerName builder with application/json body
func NewPostUsersNameServersServerNameRequest(server string, name string, serverName string, body PostUsersNameServersServerNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersNameServersServerNameRequestWithBody(server, name, serverName, "application/json", bodyReader)
}

// NewPostUsersNameServersServerNameRequestWithBody generates requests for PostUsersNameServersServerName with any type of body
func NewPostUsersNameServersServerNameRequestWithBody(server string, name string, serverName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "server_name", runtime.ParamLocationPath, serverName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersNameTokensRequest generates requests for GetUsersNameTokens
func NewGetUsersNameTokensRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUsersNameTokensRequest calls the generic PostUsersNameTokens builder with application/json body
func NewPostUsersNameTokensRequest(server string, name string, body PostUsersNameTokensJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersNameTokensRequestWithBody(server, name, "application/json", bodyReader)
}

// NewPostUsersNameTokensRequestWithBody generates requests for PostUsersNameTokens with any type of body
func NewPostUsersNameTokensRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUsersNameTokensTokenIdRequest generates requests for DeleteUsersNameTokensTokenId
func NewDeleteUsersNameTokensTokenIdRequest(server string, name string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersNameTokensTokenIdRequest generates requests for GetUsersNameTokensTokenId
func NewGetUsersNameTokensTokenIdRequest(server string, name string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// Get request
	GetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetResponse, error)

	// GetAuthorizationsCookieCookieNameCookieValue request
	GetAuthorizationsCookieCookieNameCookieValueWithResponse(ctx context.Context, cookieName string, cookieValue string, reqEditors ...RequestEditorFn) (*GetAuthorizationsCookieCookieNameCookieValueResponse, error)

	// PostAuthorizationsToken request with any body
	PostAuthorizationsTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorizationsTokenResponse, error)

	PostAuthorizationsTokenWithResponse(ctx context.Context, body PostAuthorizationsTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorizationsTokenResponse, error)

	// GetAuthorizationsTokenToken request
	GetAuthorizationsTokenTokenWithResponse(ctx context.Context, token string, reqEditors ...RequestEditorFn) (*GetAuthorizationsTokenTokenResponse, error)

	// GetGroups request
	GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error)

	// DeleteGroupsName request
	DeleteGroupsNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteGroupsNameResponse, error)

	// GetGroupsName request
	GetGroupsNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetGroupsNameResponse, error)

	// PostGroupsName request
	PostGroupsNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*PostGroupsNameResponse, error)

	// PutGroupsNameProperties request with any body
	PutGroupsNamePropertiesWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutGroupsNamePropertiesResponse, error)

	PutGroupsNamePropertiesWithResponse(ctx context.Context, name string, body PutGroupsNamePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PutGroupsNamePropertiesResponse, error)

	// DeleteGroupsNameUsers request
	DeleteGroupsNameUsersWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteGroupsNameUsersResponse, error)

	// PostGroupsNameUsers request with any body
	PostGroupsNameUsersWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGroupsNameUsersResponse, error)

	PostGroupsNameUsersWithResponse(ctx context.Context, name string, body PostGroupsNameUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGroupsNameUsersResponse, error)

	// GetInfo request
	GetInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInfoResponse, error)

	// GetOauth2Authorize request
	GetOauth2AuthorizeWithResponse(ctx context.Context, params *GetOauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*GetOauth2AuthorizeResponse, error)

	// PostOauth2Token request with any body
	PostOauth2TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOauth2TokenResponse, error)

	PostOauth2TokenWithFormdataBodyWithResponse(ctx context.Context, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostOauth2TokenResponse, error)

	// GetProxy request
	GetProxyWithResponse(ctx context.Context, params *GetProxyParams, reqEditors ...RequestEditorFn) (*GetProxyResponse, error)

	// PatchProxy request with any body
	PatchProxyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchProxyResponse, error)

	PatchProxyWithResponse(ctx context.Context, body PatchProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchProxyResponse, error)

	// PostProxy request
	PostProxyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostProxyResponse, error)

	// GetServices request
	GetServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesResponse, error)

	// GetServicesName request
	GetServicesNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetServicesNameResponse, error)

	// PostShutdown request with any body
	PostShutdownWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShutdownResponse, error)

	PostShutdownWithResponse(ctx context.Context, body PostShutdownJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShutdownResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// GetUsers request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// PostUsers request with any body
	PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersResponse, error)

	PostUsersWithResponse(ctx context.Context, body PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersResponse, error)

	// DeleteUsersName request
	DeleteUsersNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteUsersNameResponse, error)

	// GetUsersName request
	GetUsersNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetUsersNameResponse, error)

	// PatchUsersName request with any body
	PatchUsersNameWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUsersNameResponse, error)

	PatchUsersNameWithResponse(ctx context.Context, name string, body PatchUsersNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUsersNameResponse, error)

	// PostUsersName request
	PostUsersNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*PostUsersNameResponse, error)

	// PostUsersNameActivity request with any body
	PostUsersNameActivityWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersNameActivityResponse, error)

	PostUsersNameActivityWithResponse(ctx context.Context, name string, body PostUsersNameActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersNameActivityResponse, error)

	// DeleteUsersNameServer request
	DeleteUsersNameServerWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteUsersNameServerResponse, error)

	// PostUsersNameServer request with any body
	PostUsersNameServerWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersNameServerResponse, error)

	PostUsersNameServerWithResponse(ctx context.Context, name string, body PostUsersNameServerJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersNameServerResponse, error)

	// DeleteUsersNameServersServerName request
	DeleteUsersNameServersServerNameWithResponse(ctx context.Context, name string, serverName string, reqEditors ...RequestEditorFn) (*DeleteUsersNameServersServerNameResponse, error)

	// PostUsersNameServersServerName request with any body
	PostUsersNameServersServerNameWithBodyWithResponse(ctx context.Context, name string, serverName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersNameServersServerNameResponse, error)

	PostUsersNameServersServerNameWithResponse(ctx context.Context, name string, serverName string, body PostUsersNameServersServerNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersNameServersServerNameResponse, error)

	// GetUsersNameTokens request
	GetUsersNameTokensWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetUsersNameTokensResponse, error)

	// PostUsersNameTokens request with any body
	PostUsersNameTokensWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersNameTokensResponse, error)

	PostUsersNameTokensWithResponse(ctx context.Context, name string, body PostUsersNameTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersNameTokensResponse, error)

	// DeleteUsersNameTokensTokenId request
	DeleteUsersNameTokensTokenIdWithResponse(ctx context.Context, name string, tokenId string, reqEditors ...RequestEditorFn) (*DeleteUsersNameTokensTokenIdResponse, error)

	// GetUsersNameTokensTokenId request
	GetUsersNameTokensTokenIdWithResponse(ctx context.Context, name string, tokenId string, reqEditors ...RequestEditorFn) (*GetUsersNameTokensTokenIdResponse, error)
}

type GetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Version The version of JupyterHub itself
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorizationsCookieCookieNameCookieValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r GetAuthorizationsCookieCookieNameCookieValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorizationsCookieCookieNameCookieValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthorizationsTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Token The new API token.
		Token *string `json:"token,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostAuthorizationsTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthorizationsTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorizationsTokenTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAuthorizationsTokenTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorizationsTokenTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Group
}

// Status returns HTTPResponse.Status
func (r GetGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupsNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGroupsNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupsNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
}

// Status returns HTTPResponse.Status
func (r GetGroupsNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGroupsNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Group
}

// Status returns HTTPResponse.Status
func (r PostGroupsNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGroupsNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutGroupsNamePropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
}

// Status returns HTTPResponse.Status
func (r PutGroupsNamePropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutGroupsNamePropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupsNameUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGroupsNameUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupsNameUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGroupsNameUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
}

// Status returns HTTPResponse.Status
func (r PostGroupsNameUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGroupsNameUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Authenticator *struct {
			// Class The Python class currently active for JupyterHub Authentication
			Class *string `json:"class,omitempty"`

			// Version The version of the currently active Authenticator
			Version *string `json:"version,omitempty"`
		} `json:"authenticator,omitempty"`

		// Python The Python version, as returned by sys.version
		Python  *string `json:"python,omitempty"`
		Spawner *struct {
			// Class The Python class currently active for spawning single-user notebook servers
			Class *string `json:"class,omitempty"`

			// Version The version of the currently active Spawner
			Version *string `json:"version,omitempty"`
		} `json:"spawner,omitempty"`

		// SysExecutable The path to sys.executable running JupyterHub
		SysExecutable *string `json:"sys_executable,omitempty"`

		// Version The version of JupyterHub itself
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOauth2AuthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOauth2AuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOauth2AuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOauth2TokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AccessToken The new API token for the user
		AccessToken *string `json:"access_token,omitempty"`

		// TokenType Will always be 'Bearer'
		TokenType *string `json:"token_type,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostOauth2TokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOauth2TokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PatchProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Service
}

// Status returns HTTPResponse.Status
func (r GetServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
}

// Status returns HTTPResponse.Status
func (r GetServicesNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostShutdownResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostShutdownResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostShutdownResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestIdentity
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]User
}

// Status returns HTTPResponse.Status
func (r PostUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUsersNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUsersNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUsersNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r GetUsersNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUsersNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r PatchUsersNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUsersNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
}

// Status returns HTTPResponse.Status
func (r PostUsersNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersNameActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostUsersNameActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersNameActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUsersNameServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUsersNameServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUsersNameServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersNameServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostUsersNameServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersNameServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUsersNameServersServerNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUsersNameServersServerNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUsersNameServersServerNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersNameServersServerNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostUsersNameServersServerNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersNameServersServerNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersNameTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Token
}

// Status returns HTTPResponse.Status
func (r GetUsersNameTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersNameTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersNameTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Token
}

// Status returns HTTPResponse.Status
func (r PostUsersNameTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersNameTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUsersNameTokensTokenIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUsersNameTokensTokenIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUsersNameTokensTokenIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersNameTokensTokenIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Token
}

// Status returns HTTPResponse.Status
func (r GetUsersNameTokensTokenIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersNameTokensTokenIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetWithResponse request returning *GetResponse
func (c *ClientWithResponses) GetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetResponse, error) {
	rsp, err := c.Get(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResponse(rsp)
}

// GetAuthorizationsCookieCookieNameCookieValueWithResponse request returning *GetAuthorizationsCookieCookieNameCookieValueResponse
func (c *ClientWithResponses) GetAuthorizationsCookieCookieNameCookieValueWithResponse(ctx context.Context, cookieName string, cookieValue string, reqEditors ...RequestEditorFn) (*GetAuthorizationsCookieCookieNameCookieValueResponse, error) {
	rsp, err := c.GetAuthorizationsCookieCookieNameCookieValue(ctx, cookieName, cookieValue, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorizationsCookieCookieNameCookieValueResponse(rsp)
}

// PostAuthorizationsTokenWithBodyWithResponse request with arbitrary body returning *PostAuthorizationsTokenResponse
func (c *ClientWithResponses) PostAuthorizationsTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorizationsTokenResponse, error) {
	rsp, err := c.PostAuthorizationsTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorizationsTokenResponse(rsp)
}

func (c *ClientWithResponses) PostAuthorizationsTokenWithResponse(ctx context.Context, body PostAuthorizationsTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorizationsTokenResponse, error) {
	rsp, err := c.PostAuthorizationsToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorizationsTokenResponse(rsp)
}

// GetAuthorizationsTokenTokenWithResponse request returning *GetAuthorizationsTokenTokenResponse
func (c *ClientWithResponses) GetAuthorizationsTokenTokenWithResponse(ctx context.Context, token string, reqEditors ...RequestEditorFn) (*GetAuthorizationsTokenTokenResponse, error) {
	rsp, err := c.GetAuthorizationsTokenToken(ctx, token, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorizationsTokenTokenResponse(rsp)
}

// GetGroupsWithResponse request returning *GetGroupsResponse
func (c *ClientWithResponses) GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error) {
	rsp, err := c.GetGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsResponse(rsp)
}

// DeleteGroupsNameWithResponse request returning *DeleteGroupsNameResponse
func (c *ClientWithResponses) DeleteGroupsNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteGroupsNameResponse, error) {
	rsp, err := c.DeleteGroupsName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupsNameResponse(rsp)
}

// GetGroupsNameWithResponse request returning *GetGroupsNameResponse
func (c *ClientWithResponses) GetGroupsNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetGroupsNameResponse, error) {
	rsp, err := c.GetGroupsName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsNameResponse(rsp)
}

// PostGroupsNameWithResponse request returning *PostGroupsNameResponse
func (c *ClientWithResponses) PostGroupsNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*PostGroupsNameResponse, error) {
	rsp, err := c.PostGroupsName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGroupsNameResponse(rsp)
}

// PutGroupsNamePropertiesWithBodyWithResponse request with arbitrary body returning *PutGroupsNamePropertiesResponse
func (c *ClientWithResponses) PutGroupsNamePropertiesWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutGroupsNamePropertiesResponse, error) {
	rsp, err := c.PutGroupsNamePropertiesWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutGroupsNamePropertiesResponse(rsp)
}

func (c *ClientWithResponses) PutGroupsNamePropertiesWithResponse(ctx context.Context, name string, body PutGroupsNamePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PutGroupsNamePropertiesResponse, error) {
	rsp, err := c.PutGroupsNameProperties(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutGroupsNamePropertiesResponse(rsp)
}

// DeleteGroupsNameUsersWithResponse request returning *DeleteGroupsNameUsersResponse
func (c *ClientWithResponses) DeleteGroupsNameUsersWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteGroupsNameUsersResponse, error) {
	rsp, err := c.DeleteGroupsNameUsers(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupsNameUsersResponse(rsp)
}

// PostGroupsNameUsersWithBodyWithResponse request with arbitrary body returning *PostGroupsNameUsersResponse
func (c *ClientWithResponses) PostGroupsNameUsersWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGroupsNameUsersResponse, error) {
	rsp, err := c.PostGroupsNameUsersWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGroupsNameUsersResponse(rsp)
}

func (c *ClientWithResponses) PostGroupsNameUsersWithResponse(ctx context.Context, name string, body PostGroupsNameUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGroupsNameUsersResponse, error) {
	rsp, err := c.PostGroupsNameUsers(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGroupsNameUsersResponse(rsp)
}

// GetInfoWithResponse request returning *GetInfoResponse
func (c *ClientWithResponses) GetInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInfoResponse, error) {
	rsp, err := c.GetInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInfoResponse(rsp)
}

// GetOauth2AuthorizeWithResponse request returning *GetOauth2AuthorizeResponse
func (c *ClientWithResponses) GetOauth2AuthorizeWithResponse(ctx context.Context, params *GetOauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*GetOauth2AuthorizeResponse, error) {
	rsp, err := c.GetOauth2Authorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOauth2AuthorizeResponse(rsp)
}

// PostOauth2TokenWithBodyWithResponse request with arbitrary body returning *PostOauth2TokenResponse
func (c *ClientWithResponses) PostOauth2TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOauth2TokenResponse, error) {
	rsp, err := c.PostOauth2TokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOauth2TokenResponse(rsp)
}

func (c *ClientWithResponses) PostOauth2TokenWithFormdataBodyWithResponse(ctx context.Context, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostOauth2TokenResponse, error) {
	rsp, err := c.PostOauth2TokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOauth2TokenResponse(rsp)
}

// GetProxyWithResponse request returning *GetProxyResponse
func (c *ClientWithResponses) GetProxyWithResponse(ctx context.Context, params *GetProxyParams, reqEditors ...RequestEditorFn) (*GetProxyResponse, error) {
	rsp, err := c.GetProxy(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProxyResponse(rsp)
}

// PatchProxyWithBodyWithResponse request with arbitrary body returning *PatchProxyResponse
func (c *ClientWithResponses) PatchProxyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchProxyResponse, error) {
	rsp, err := c.PatchProxyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchProxyResponse(rsp)
}

func (c *ClientWithResponses) PatchProxyWithResponse(ctx context.Context, body PatchProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchProxyResponse, error) {
	rsp, err := c.PatchProxy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchProxyResponse(rsp)
}

// PostProxyWithResponse request returning *PostProxyResponse
func (c *ClientWithResponses) PostProxyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostProxyResponse, error) {
	rsp, err := c.PostProxy(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProxyResponse(rsp)
}

// GetServicesWithResponse request returning *GetServicesResponse
func (c *ClientWithResponses) GetServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesResponse, error) {
	rsp, err := c.GetServices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesResponse(rsp)
}

// GetServicesNameWithResponse request returning *GetServicesNameResponse
func (c *ClientWithResponses) GetServicesNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetServicesNameResponse, error) {
	rsp, err := c.GetServicesName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesNameResponse(rsp)
}

// PostShutdownWithBodyWithResponse request with arbitrary body returning *PostShutdownResponse
func (c *ClientWithResponses) PostShutdownWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShutdownResponse, error) {
	rsp, err := c.PostShutdownWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShutdownResponse(rsp)
}

func (c *ClientWithResponses) PostShutdownWithResponse(ctx context.Context, body PostShutdownJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShutdownResponse, error) {
	rsp, err := c.PostShutdown(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShutdownResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// PostUsersWithBodyWithResponse request with arbitrary body returning *PostUsersResponse
func (c *ClientWithResponses) PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersResponse, error) {
	rsp, err := c.PostUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersResponse(rsp)
}

func (c *ClientWithResponses) PostUsersWithResponse(ctx context.Context, body PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersResponse, error) {
	rsp, err := c.PostUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersResponse(rsp)
}

// DeleteUsersNameWithResponse request returning *DeleteUsersNameResponse
func (c *ClientWithResponses) DeleteUsersNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteUsersNameResponse, error) {
	rsp, err := c.DeleteUsersName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUsersNameResponse(rsp)
}

// GetUsersNameWithResponse request returning *GetUsersNameResponse
func (c *ClientWithResponses) GetUsersNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetUsersNameResponse, error) {
	rsp, err := c.GetUsersName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersNameResponse(rsp)
}

// PatchUsersNameWithBodyWithResponse request with arbitrary body returning *PatchUsersNameResponse
func (c *ClientWithResponses) PatchUsersNameWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUsersNameResponse, error) {
	rsp, err := c.PatchUsersNameWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUsersNameResponse(rsp)
}

func (c *ClientWithResponses) PatchUsersNameWithResponse(ctx context.Context, name string, body PatchUsersNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUsersNameResponse, error) {
	rsp, err := c.PatchUsersName(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUsersNameResponse(rsp)
}

// PostUsersNameWithResponse request returning *PostUsersNameResponse
func (c *ClientWithResponses) PostUsersNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*PostUsersNameResponse, error) {
	rsp, err := c.PostUsersName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersNameResponse(rsp)
}

// PostUsersNameActivityWithBodyWithResponse request with arbitrary body returning *PostUsersNameActivityResponse
func (c *ClientWithResponses) PostUsersNameActivityWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersNameActivityResponse, error) {
	rsp, err := c.PostUsersNameActivityWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersNameActivityResponse(rsp)
}

func (c *ClientWithResponses) PostUsersNameActivityWithResponse(ctx context.Context, name string, body PostUsersNameActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersNameActivityResponse, error) {
	rsp, err := c.PostUsersNameActivity(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersNameActivityResponse(rsp)
}

// DeleteUsersNameServerWithResponse request returning *DeleteUsersNameServerResponse
func (c *ClientWithResponses) DeleteUsersNameServerWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteUsersNameServerResponse, error) {
	rsp, err := c.DeleteUsersNameServer(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUsersNameServerResponse(rsp)
}

// PostUsersNameServerWithBodyWithResponse request with arbitrary body returning *PostUsersNameServerResponse
func (c *ClientWithResponses) PostUsersNameServerWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersNameServerResponse, error) {
	rsp, err := c.PostUsersNameServerWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersNameServerResponse(rsp)
}

func (c *ClientWithResponses) PostUsersNameServerWithResponse(ctx context.Context, name string, body PostUsersNameServerJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersNameServerResponse, error) {
	rsp, err := c.PostUsersNameServer(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersNameServerResponse(rsp)
}

// DeleteUsersNameServersServerNameWithResponse request returning *DeleteUsersNameServersServerNameResponse
func (c *ClientWithResponses) DeleteUsersNameServersServerNameWithResponse(ctx context.Context, name string, serverName string, reqEditors ...RequestEditorFn) (*DeleteUsersNameServersServerNameResponse, error) {
	rsp, err := c.DeleteUsersNameServersServerName(ctx, name, serverName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUsersNameServersServerNameResponse(rsp)
}

// PostUsersNameServersServerNameWithBodyWithResponse request with arbitrary body returning *PostUsersNameServersServerNameResponse
func (c *ClientWithResponses) PostUsersNameServersServerNameWithBodyWithResponse(ctx context.Context, name string, serverName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersNameServersServerNameResponse, error) {
	rsp, err := c.PostUsersNameServersServerNameWithBody(ctx, name, serverName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersNameServersServerNameResponse(rsp)
}

func (c *ClientWithResponses) PostUsersNameServersServerNameWithResponse(ctx context.Context, name string, serverName string, body PostUsersNameServersServerNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersNameServersServerNameResponse, error) {
	rsp, err := c.PostUsersNameServersServerName(ctx, name, serverName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersNameServersServerNameResponse(rsp)
}

// GetUsersNameTokensWithResponse request returning *GetUsersNameTokensResponse
func (c *ClientWithResponses) GetUsersNameTokensWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetUsersNameTokensResponse, error) {
	rsp, err := c.GetUsersNameTokens(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersNameTokensResponse(rsp)
}

// PostUsersNameTokensWithBodyWithResponse request with arbitrary body returning *PostUsersNameTokensResponse
func (c *ClientWithResponses) PostUsersNameTokensWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersNameTokensResponse, error) {
	rsp, err := c.PostUsersNameTokensWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersNameTokensResponse(rsp)
}

func (c *ClientWithResponses) PostUsersNameTokensWithResponse(ctx context.Context, name string, body PostUsersNameTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersNameTokensResponse, error) {
	rsp, err := c.PostUsersNameTokens(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersNameTokensResponse(rsp)
}

// DeleteUsersNameTokensTokenIdWithResponse request returning *DeleteUsersNameTokensTokenIdResponse
func (c *ClientWithResponses) DeleteUsersNameTokensTokenIdWithResponse(ctx context.Context, name string, tokenId string, reqEditors ...RequestEditorFn) (*DeleteUsersNameTokensTokenIdResponse, error) {
	rsp, err := c.DeleteUsersNameTokensTokenId(ctx, name, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUsersNameTokensTokenIdResponse(rsp)
}

// GetUsersNameTokensTokenIdWithResponse request returning *GetUsersNameTokensTokenIdResponse
func (c *ClientWithResponses) GetUsersNameTokensTokenIdWithResponse(ctx context.Context, name string, tokenId string, reqEditors ...RequestEditorFn) (*GetUsersNameTokensTokenIdResponse, error) {
	rsp, err := c.GetUsersNameTokensTokenId(ctx, name, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersNameTokensTokenIdResponse(rsp)
}

// ParseGetResponse parses an HTTP response from a GetWithResponse call
func ParseGetResponse(rsp *http.Response) (*GetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Version The version of JupyterHub itself
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAuthorizationsCookieCookieNameCookieValueResponse parses an HTTP response from a GetAuthorizationsCookieCookieNameCookieValueWithResponse call
func ParseGetAuthorizationsCookieCookieNameCookieValueResponse(rsp *http.Response) (*GetAuthorizationsCookieCookieNameCookieValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorizationsCookieCookieNameCookieValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAuthorizationsTokenResponse parses an HTTP response from a PostAuthorizationsTokenWithResponse call
func ParsePostAuthorizationsTokenResponse(rsp *http.Response) (*PostAuthorizationsTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthorizationsTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Token The new API token.
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAuthorizationsTokenTokenResponse parses an HTTP response from a GetAuthorizationsTokenTokenWithResponse call
func ParseGetAuthorizationsTokenTokenResponse(rsp *http.Response) (*GetAuthorizationsTokenTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorizationsTokenTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGroupsResponse parses an HTTP response from a GetGroupsWithResponse call
func ParseGetGroupsResponse(rsp *http.Response) (*GetGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteGroupsNameResponse parses an HTTP response from a DeleteGroupsNameWithResponse call
func ParseDeleteGroupsNameResponse(rsp *http.Response) (*DeleteGroupsNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupsNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGroupsNameResponse parses an HTTP response from a GetGroupsNameWithResponse call
func ParseGetGroupsNameResponse(rsp *http.Response) (*GetGroupsNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostGroupsNameResponse parses an HTTP response from a PostGroupsNameWithResponse call
func ParsePostGroupsNameResponse(rsp *http.Response) (*PostGroupsNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGroupsNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParsePutGroupsNamePropertiesResponse parses an HTTP response from a PutGroupsNamePropertiesWithResponse call
func ParsePutGroupsNamePropertiesResponse(rsp *http.Response) (*PutGroupsNamePropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutGroupsNamePropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteGroupsNameUsersResponse parses an HTTP response from a DeleteGroupsNameUsersWithResponse call
func ParseDeleteGroupsNameUsersResponse(rsp *http.Response) (*DeleteGroupsNameUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupsNameUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostGroupsNameUsersResponse parses an HTTP response from a PostGroupsNameUsersWithResponse call
func ParsePostGroupsNameUsersResponse(rsp *http.Response) (*PostGroupsNameUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGroupsNameUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInfoResponse parses an HTTP response from a GetInfoWithResponse call
func ParseGetInfoResponse(rsp *http.Response) (*GetInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Authenticator *struct {
				// Class The Python class currently active for JupyterHub Authentication
				Class *string `json:"class,omitempty"`

				// Version The version of the currently active Authenticator
				Version *string `json:"version,omitempty"`
			} `json:"authenticator,omitempty"`

			// Python The Python version, as returned by sys.version
			Python  *string `json:"python,omitempty"`
			Spawner *struct {
				// Class The Python class currently active for spawning single-user notebook servers
				Class *string `json:"class,omitempty"`

				// Version The version of the currently active Spawner
				Version *string `json:"version,omitempty"`
			} `json:"spawner,omitempty"`

			// SysExecutable The path to sys.executable running JupyterHub
			SysExecutable *string `json:"sys_executable,omitempty"`

			// Version The version of JupyterHub itself
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOauth2AuthorizeResponse parses an HTTP response from a GetOauth2AuthorizeWithResponse call
func ParseGetOauth2AuthorizeResponse(rsp *http.Response) (*GetOauth2AuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOauth2AuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostOauth2TokenResponse parses an HTTP response from a PostOauth2TokenWithResponse call
func ParsePostOauth2TokenResponse(rsp *http.Response) (*PostOauth2TokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOauth2TokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AccessToken The new API token for the user
			AccessToken *string `json:"access_token,omitempty"`

			// TokenType Will always be 'Bearer'
			TokenType *string `json:"token_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProxyResponse parses an HTTP response from a GetProxyWithResponse call
func ParseGetProxyResponse(rsp *http.Response) (*GetProxyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchProxyResponse parses an HTTP response from a PatchProxyWithResponse call
func ParsePatchProxyResponse(rsp *http.Response) (*PatchProxyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostProxyResponse parses an HTTP response from a PostProxyWithResponse call
func ParsePostProxyResponse(rsp *http.Response) (*PostProxyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetServicesResponse parses an HTTP response from a GetServicesWithResponse call
func ParseGetServicesResponse(rsp *http.Response) (*GetServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServicesNameResponse parses an HTTP response from a GetServicesNameWithResponse call
func ParseGetServicesNameResponse(rsp *http.Response) (*GetServicesNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostShutdownResponse parses an HTTP response from a PostShutdownWithResponse call
func ParsePostShutdownResponse(rsp *http.Response) (*PostShutdownResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostShutdownResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestIdentity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostUsersResponse parses an HTTP response from a PostUsersWithResponse call
func ParsePostUsersResponse(rsp *http.Response) (*PostUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteUsersNameResponse parses an HTTP response from a DeleteUsersNameWithResponse call
func ParseDeleteUsersNameResponse(rsp *http.Response) (*DeleteUsersNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUsersNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsersNameResponse parses an HTTP response from a GetUsersNameWithResponse call
func ParseGetUsersNameResponse(rsp *http.Response) (*GetUsersNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchUsersNameResponse parses an HTTP response from a PatchUsersNameWithResponse call
func ParsePatchUsersNameResponse(rsp *http.Response) (*PatchUsersNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUsersNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostUsersNameResponse parses an HTTP response from a PostUsersNameWithResponse call
func ParsePostUsersNameResponse(rsp *http.Response) (*PostUsersNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParsePostUsersNameActivityResponse parses an HTTP response from a PostUsersNameActivityWithResponse call
func ParsePostUsersNameActivityResponse(rsp *http.Response) (*PostUsersNameActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersNameActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteUsersNameServerResponse parses an HTTP response from a DeleteUsersNameServerWithResponse call
func ParseDeleteUsersNameServerResponse(rsp *http.Response) (*DeleteUsersNameServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUsersNameServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostUsersNameServerResponse parses an HTTP response from a PostUsersNameServerWithResponse call
func ParsePostUsersNameServerResponse(rsp *http.Response) (*PostUsersNameServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersNameServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteUsersNameServersServerNameResponse parses an HTTP response from a DeleteUsersNameServersServerNameWithResponse call
func ParseDeleteUsersNameServersServerNameResponse(rsp *http.Response) (*DeleteUsersNameServersServerNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUsersNameServersServerNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostUsersNameServersServerNameResponse parses an HTTP response from a PostUsersNameServersServerNameWithResponse call
func ParsePostUsersNameServersServerNameResponse(rsp *http.Response) (*PostUsersNameServersServerNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersNameServersServerNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsersNameTokensResponse parses an HTTP response from a GetUsersNameTokensWithResponse call
func ParseGetUsersNameTokensResponse(rsp *http.Response) (*GetUsersNameTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersNameTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Token
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostUsersNameTokensResponse parses an HTTP response from a PostUsersNameTokensWithResponse call
func ParsePostUsersNameTokensResponse(rsp *http.Response) (*PostUsersNameTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersNameTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Token
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteUsersNameTokensTokenIdResponse parses an HTTP response from a DeleteUsersNameTokensTokenIdWithResponse call
func ParseDeleteUsersNameTokensTokenIdResponse(rsp *http.Response) (*DeleteUsersNameTokensTokenIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUsersNameTokensTokenIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsersNameTokensTokenIdResponse parses an HTTP response from a GetUsersNameTokensTokenIdWithResponse call
func ParseGetUsersNameTokensTokenIdResponse(rsp *http.Response) (*GetUsersNameTokensTokenIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersNameTokensTokenIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Token
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get JupyterHub version
	// (GET /)
	Get(ctx echo.Context) error
	// Identify a user from a cookie
	// (GET /authorizations/cookie/{cookie_name}/{cookie_value})
	GetAuthorizationsCookieCookieNameCookieValue(ctx echo.Context, cookieName string, cookieValue string) error
	// Request a new API token
	// (POST /authorizations/token)
	PostAuthorizationsToken(ctx echo.Context) error
	// Identify a user or service from an API token
	// (GET /authorizations/token/{token})
	GetAuthorizationsTokenToken(ctx echo.Context, token string) error
	// List groups
	// (GET /groups)
	GetGroups(ctx echo.Context, params GetGroupsParams) error
	// Delete a group
	// (DELETE /groups/{name})
	DeleteGroupsName(ctx echo.Context, name string) error
	// Get a group by name
	// (GET /groups/{name})
	GetGroupsName(ctx echo.Context, name string) error
	// Create a group
	// (POST /groups/{name})
	PostGroupsName(ctx echo.Context, name string) error
	// Set the group properties.
	//
	// Added in JupyterHub 3.2.
	// (PUT /groups/{name}/properties)
	PutGroupsNameProperties(ctx echo.Context, name string) error
	// Remove users from a group
	// (DELETE /groups/{name}/users)
	DeleteGroupsNameUsers(ctx echo.Context, name string) error
	// Add users to a group
	// (POST /groups/{name}/users)
	PostGroupsNameUsers(ctx echo.Context, name string) error
	// Get detailed info about JupyterHub
	// (GET /info)
	GetInfo(ctx echo.Context) error
	// OAuth 2.0 authorize endpoint
	// (GET /oauth2/authorize)
	GetOauth2Authorize(ctx echo.Context, params GetOauth2AuthorizeParams) error
	// Request an OAuth2 token
	// (POST /oauth2/token)
	PostOauth2Token(ctx echo.Context) error
	// Get the proxy's routing table
	// (GET /proxy)
	GetProxy(ctx echo.Context, params GetProxyParams) error
	// Notify the Hub about a new proxy
	// (PATCH /proxy)
	PatchProxy(ctx echo.Context) error
	// Force the Hub to sync with the proxy
	// (POST /proxy)
	PostProxy(ctx echo.Context) error
	// List services
	// (GET /services)
	GetServices(ctx echo.Context) error
	// Get a service by name
	// (GET /services/{name})
	GetServicesName(ctx echo.Context, name string) error
	// Shutdown the Hub
	// (POST /shutdown)
	PostShutdown(ctx echo.Context) error
	// Return authenticated user's model
	// (GET /user)
	GetUser(ctx echo.Context) error
	// List users
	// (GET /users)
	GetUsers(ctx echo.Context, params GetUsersParams) error
	// Create multiple users
	// (POST /users)
	PostUsers(ctx echo.Context) error
	// Delete a user
	// (DELETE /users/{name})
	DeleteUsersName(ctx echo.Context, name string) error
	// Get a user by name
	// (GET /users/{name})
	GetUsersName(ctx echo.Context, name string) error
	// Modify a user
	// (PATCH /users/{name})
	PatchUsersName(ctx echo.Context, name string) error
	// Create a single user
	// (POST /users/{name})
	PostUsersName(ctx echo.Context, name string) error
	// Notify Hub of activity for a given user.
	// (POST /users/{name}/activity)
	PostUsersNameActivity(ctx echo.Context, name string) error
	// Stop a user's server
	// (DELETE /users/{name}/server)
	DeleteUsersNameServer(ctx echo.Context, name string) error
	// Start a user's single-user notebook server
	// (POST /users/{name}/server)
	PostUsersNameServer(ctx echo.Context, name string) error
	// Stop a user's named server
	// (DELETE /users/{name}/servers/{server_name})
	DeleteUsersNameServersServerName(ctx echo.Context, name string, serverName string) error
	// Start a user's single-user named-server notebook server
	// (POST /users/{name}/servers/{server_name})
	PostUsersNameServersServerName(ctx echo.Context, name string, serverName string) error
	// List tokens for the user
	// (GET /users/{name}/tokens)
	GetUsersNameTokens(ctx echo.Context, name string) error
	// Create a new token for the user
	// (POST /users/{name}/tokens)
	PostUsersNameTokens(ctx echo.Context, name string) error
	// Delete (revoke) a token by id
	// (DELETE /users/{name}/tokens/{token_id})
	DeleteUsersNameTokensTokenId(ctx echo.Context, name string, tokenId string) error
	// Get the model for a token by id
	// (GET /users/{name}/tokens/{token_id})
	GetUsersNameTokensTokenId(ctx echo.Context, name string, tokenId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Get converts echo context to params.
func (w *ServerInterfaceWrapper) Get(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{})

	ctx.Set(Oauth2Scopes, []string{"self"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Get(ctx)
	return err
}

// GetAuthorizationsCookieCookieNameCookieValue converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthorizationsCookieCookieNameCookieValue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "cookie_name" -------------
	var cookieName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cookie_name", runtime.ParamLocationPath, ctx.Param("cookie_name"), &cookieName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cookie_name: %s", err))
	}

	// ------------- Path parameter "cookie_value" -------------
	var cookieValue string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cookie_value", runtime.ParamLocationPath, ctx.Param("cookie_value"), &cookieValue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cookie_value: %s", err))
	}

	ctx.Set(TokenScopes, []string{})

	ctx.Set(Oauth2Scopes, []string{"self"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAuthorizationsCookieCookieNameCookieValue(ctx, cookieName, cookieValue)
	return err
}

// PostAuthorizationsToken converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthorizationsToken(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"tokens"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostAuthorizationsToken(ctx)
	return err
}

// GetAuthorizationsTokenToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthorizationsTokenToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameterWithLocation("simple", false, "token", runtime.ParamLocationPath, ctx.Param("token"), &token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"(no_scope)"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAuthorizationsTokenToken(ctx, token)
	return err
}

// GetGroups converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroups(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"read:groups", "read:groups:name", "read:roles:groups"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGroups(ctx, params)
	return err
}

// DeleteGroupsName converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGroupsName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin:groups"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteGroupsName(ctx, name)
	return err
}

// GetGroupsName converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroupsName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"read:groups", "read:groups:name", "read:roles:groups"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGroupsName(ctx, name)
	return err
}

// PostGroupsName converts echo context to params.
func (w *ServerInterfaceWrapper) PostGroupsName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin:groups"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostGroupsName(ctx, name)
	return err
}

// PutGroupsNameProperties converts echo context to params.
func (w *ServerInterfaceWrapper) PutGroupsNameProperties(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"groups"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutGroupsNameProperties(ctx, name)
	return err
}

// DeleteGroupsNameUsers converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGroupsNameUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"groups"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteGroupsNameUsers(ctx, name)
	return err
}

// PostGroupsNameUsers converts echo context to params.
func (w *ServerInterfaceWrapper) PostGroupsNameUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"groups"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostGroupsNameUsers(ctx, name)
	return err
}

// GetInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetInfo(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"read:hub"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetInfo(ctx)
	return err
}

// GetOauth2Authorize converts echo context to params.
func (w *ServerInterfaceWrapper) GetOauth2Authorize(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{})

	ctx.Set(Oauth2Scopes, []string{"self"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOauth2AuthorizeParams
	// ------------- Required query parameter "client_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "client_id", ctx.QueryParams(), &params.ClientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	// ------------- Required query parameter "response_type" -------------

	err = runtime.BindQueryParameter("form", true, true, "response_type", ctx.QueryParams(), &params.ResponseType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter response_type: %s", err))
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Required query parameter "redirect_uri" -------------

	err = runtime.BindQueryParameter("form", true, true, "redirect_uri", ctx.QueryParams(), &params.RedirectUri)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter redirect_uri: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOauth2Authorize(ctx, params)
	return err
}

// PostOauth2Token converts echo context to params.
func (w *ServerInterfaceWrapper) PostOauth2Token(ctx echo.Context) error {
	var err error

	ctx.Set(TokenScopes, []string{})

	ctx.Set(Oauth2Scopes, []string{"self"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostOauth2Token(ctx)
	return err
}

// GetProxy converts echo context to params.
func (w *ServerInterfaceWrapper) GetProxy(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"proxy"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProxyParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProxy(ctx, params)
	return err
}

// PatchProxy converts echo context to params.
func (w *ServerInterfaceWrapper) PatchProxy(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"proxy"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchProxy(ctx)
	return err
}

// PostProxy converts echo context to params.
func (w *ServerInterfaceWrapper) PostProxy(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"proxy"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostProxy(ctx)
	return err
}

// GetServices converts echo context to params.
func (w *ServerInterfaceWrapper) GetServices(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"read:services", "read:services:name", "read:roles:services"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServices(ctx)
	return err
}

// GetServicesName converts echo context to params.
func (w *ServerInterfaceWrapper) GetServicesName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"read:services", "read:services:name", "read:roles:services"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServicesName(ctx, name)
	return err
}

// PostShutdown converts echo context to params.
func (w *ServerInterfaceWrapper) PostShutdown(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"shutdown"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostShutdown(ctx)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"read:users", "read:users:name", "read:users:groups", "read:users:activity", "read:servers", "read:roles:users", "admin:auth_state", "admin:server_state"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"read:users", "read:users:name", "read:users:groups", "read:users:activity", "read:servers", "read:roles:users", "admin:auth_state", "admin:server_state"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams
	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include_stopped_servers" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_stopped_servers", ctx.QueryParams(), &params.IncludeStoppedServers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include_stopped_servers: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsers(ctx, params)
	return err
}

// PostUsers converts echo context to params.
func (w *ServerInterfaceWrapper) PostUsers(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"admin:users"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUsers(ctx)
	return err
}

// DeleteUsersName converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUsersName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin:users"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteUsersName(ctx, name)
	return err
}

// GetUsersName converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"read:users", "read:users:name", "read:users:groups", "read:users:activity", "read:servers", "read:roles:users", "admin:auth_state", "admin:server_state"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsersName(ctx, name)
	return err
}

// PatchUsersName converts echo context to params.
func (w *ServerInterfaceWrapper) PatchUsersName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin:users"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchUsersName(ctx, name)
	return err
}

// PostUsersName converts echo context to params.
func (w *ServerInterfaceWrapper) PostUsersName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"admin:users"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUsersName(ctx, name)
	return err
}

// PostUsersNameActivity converts echo context to params.
func (w *ServerInterfaceWrapper) PostUsersNameActivity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"users:activity"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUsersNameActivity(ctx, name)
	return err
}

// DeleteUsersNameServer converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUsersNameServer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"servers"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteUsersNameServer(ctx, name)
	return err
}

// PostUsersNameServer converts echo context to params.
func (w *ServerInterfaceWrapper) PostUsersNameServer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"servers"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUsersNameServer(ctx, name)
	return err
}

// DeleteUsersNameServersServerName converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUsersNameServersServerName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Path parameter "server_name" -------------
	var serverName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "server_name", runtime.ParamLocationPath, ctx.Param("server_name"), &serverName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter server_name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"servers"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteUsersNameServersServerName(ctx, name, serverName)
	return err
}

// PostUsersNameServersServerName converts echo context to params.
func (w *ServerInterfaceWrapper) PostUsersNameServersServerName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Path parameter "server_name" -------------
	var serverName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "server_name", runtime.ParamLocationPath, ctx.Param("server_name"), &serverName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter server_name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"servers"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUsersNameServersServerName(ctx, name, serverName)
	return err
}

// GetUsersNameTokens converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersNameTokens(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"read:tokens"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsersNameTokens(ctx, name)
	return err
}

// PostUsersNameTokens converts echo context to params.
func (w *ServerInterfaceWrapper) PostUsersNameTokens(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"tokens"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUsersNameTokens(ctx, name)
	return err
}

// DeleteUsersNameTokensTokenId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUsersNameTokensTokenId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Path parameter "token_id" -------------
	var tokenId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "token_id", runtime.ParamLocationPath, ctx.Param("token_id"), &tokenId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token_id: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"tokens"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteUsersNameTokensTokenId(ctx, name, tokenId)
	return err
}

// GetUsersNameTokensTokenId converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersNameTokensTokenId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Path parameter "token_id" -------------
	var tokenId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "token_id", runtime.ParamLocationPath, ctx.Param("token_id"), &tokenId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token_id: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"read:tokens"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsersNameTokensTokenId(ctx, name, tokenId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.Get)
	router.GET(baseURL+"/authorizations/cookie/:cookie_name/:cookie_value", wrapper.GetAuthorizationsCookieCookieNameCookieValue)
	router.POST(baseURL+"/authorizations/token", wrapper.PostAuthorizationsToken)
	router.GET(baseURL+"/authorizations/token/:token", wrapper.GetAuthorizationsTokenToken)
	router.GET(baseURL+"/groups", wrapper.GetGroups)
	router.DELETE(baseURL+"/groups/:name", wrapper.DeleteGroupsName)
	router.GET(baseURL+"/groups/:name", wrapper.GetGroupsName)
	router.POST(baseURL+"/groups/:name", wrapper.PostGroupsName)
	router.PUT(baseURL+"/groups/:name/properties", wrapper.PutGroupsNameProperties)
	router.DELETE(baseURL+"/groups/:name/users", wrapper.DeleteGroupsNameUsers)
	router.POST(baseURL+"/groups/:name/users", wrapper.PostGroupsNameUsers)
	router.GET(baseURL+"/info", wrapper.GetInfo)
	router.GET(baseURL+"/oauth2/authorize", wrapper.GetOauth2Authorize)
	router.POST(baseURL+"/oauth2/token", wrapper.PostOauth2Token)
	router.GET(baseURL+"/proxy", wrapper.GetProxy)
	router.PATCH(baseURL+"/proxy", wrapper.PatchProxy)
	router.POST(baseURL+"/proxy", wrapper.PostProxy)
	router.GET(baseURL+"/services", wrapper.GetServices)
	router.GET(baseURL+"/services/:name", wrapper.GetServicesName)
	router.POST(baseURL+"/shutdown", wrapper.PostShutdown)
	router.GET(baseURL+"/user", wrapper.GetUser)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.POST(baseURL+"/users", wrapper.PostUsers)
	router.DELETE(baseURL+"/users/:name", wrapper.DeleteUsersName)
	router.GET(baseURL+"/users/:name", wrapper.GetUsersName)
	router.PATCH(baseURL+"/users/:name", wrapper.PatchUsersName)
	router.POST(baseURL+"/users/:name", wrapper.PostUsersName)
	router.POST(baseURL+"/users/:name/activity", wrapper.PostUsersNameActivity)
	router.DELETE(baseURL+"/users/:name/server", wrapper.DeleteUsersNameServer)
	router.POST(baseURL+"/users/:name/server", wrapper.PostUsersNameServer)
	router.DELETE(baseURL+"/users/:name/servers/:server_name", wrapper.DeleteUsersNameServersServerName)
	router.POST(baseURL+"/users/:name/servers/:server_name", wrapper.PostUsersNameServersServerName)
	router.GET(baseURL+"/users/:name/tokens", wrapper.GetUsersNameTokens)
	router.POST(baseURL+"/users/:name/tokens", wrapper.PostUsersNameTokens)
	router.DELETE(baseURL+"/users/:name/tokens/:token_id", wrapper.DeleteUsersNameTokensTokenId)
	router.GET(baseURL+"/users/:name/tokens/:token_id", wrapper.GetUsersNameTokensTokenId)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"0M8f6SHVUXgFYHT37u5/AwAA///lgOCxDYQAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
